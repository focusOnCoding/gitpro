<# Environment Variables
Git always runs inside a bash shell, and uses a number of shell environment variables to determine
how it behaves. Occasionally, it comes in handy to know what these are, and how they can be used
to make Git behave the way you want it to. This isn’t an exhaustive list of all the environment
variables Git pays attention to, but we’ll cover the most useful.

<# Global Behavior
Some of Git’s general behavior as a computer program depends on environment variables.

GIT_EXEC_PATH determines where Git looks for its sub-programs (like git-commit, git-diff, and
others). You can check the current setting by running git --exec-path.

HOME isn’t usually considered customizable (too many other things depend on it), but it’s where Git
looks for the global configuration file. If you want a truly portable Git installation, complete with
global configuration, you can override HOME in the portable Git’s shell profile.

PREFIX is similar, but for the system-wide configuration. Git looks for this file at
$PREFIX/etc/gitconfig.

GIT_CONFIG_NOSYSTEM, if set, disables the use of the system-wide configuration file. This is useful if
your system config is interfering with your commands, but you don’t have access to change or
remove it.

GIT_PAGER controls the program used to display multi-page output on the command line. If this is
unset, PAGER will be used as a fallback.

GIT_EDITOR is the editor Git will launch when the user needs to edit some text (a commit message,
for example). If unset, EDITOR will be used.

<# Repository Locations
Git uses several environment variables to determine how it interfaces with the current repository.

GIT_DIR is the location of the .git folder. If this isn’t specified, Git walks up the directory tree until it
gets to ~ or /, looking for a .git directory at every step.

GIT_CEILING_DIRECTORIES controls the behavior of searching for a .git directory. If you access
directories that are slow to load (such as those on a tape drive, or across a slow network
connection), you may want to have Git stop trying earlier than it might otherwise, especially if Git is
invoked when building your shell prompt.

GIT_WORK_TREE is the location of the root of the working directory for a non-bare repository. If --git
-dir or GIT_DIR is specified but none of --work-tree, GIT_WORK_TREE or core.worktree is specified, the
current working directory is regarded as the top level of your working tree.

GIT_INDEX_FILE is the path to the index file (non-bare repositories only).

GIT_OBJECT_DIRECTORY can be used to specify the location of the directory that usually resides at
.git/objects.

<# GIT_ALTERNATE_OBJECT_DIRECTORIES is a colon-separated list (formatted like /dir/one:/dir/two:…)
which tells Git where to check for objects if they aren’t in GIT_OBJECT_DIRECTORY. If you happen to
have a lot of projects with large files that have the exact same contents, this can be used to avoid
storing too many copies of them.

<# Pathspecs
A “pathspec” refers to how you specify paths to things in Git, including the use of wildcards. These
are used in the .gitignore file, but also on the command-line (git add *.c).

GIT_GLOB_PATHSPECS and GIT_NOGLOB_PATHSPECS control the default behavior of wildcards in
pathspecs. If GIT_GLOB_PATHSPECS is set to 1, wildcard characters act as wildcards (which is the
default); if GIT_NOGLOB_PATHSPECS is set to 1, wildcard characters only match themselves, meaning
something like *.c would only match a file named “*.c”, rather than any file whose name ends with
.c. You can override this in individual cases by starting the pathspec with :(glob) or :(literal), as
in :(glob)*.c.

GIT_LITERAL_PATHSPECS disables both of the above behaviors; no wildcard characters will work, and
the override prefixes are disabled as well.

GIT_ICASE_PATHSPECS sets all pathspecs to work in a case-insensitive manner.

<# Committing
The final creation of a Git commit object is usually done by git-commit-tree, which uses these
environment variables as its primary source of information, falling back to configuration values
only if these aren’t present.

GIT_AUTHOR_NAME is the human-readable name in the “author” field.

GIT_AUTHOR_EMAIL is the email for the “author” field.

GIT_AUTHOR_DATE is the timestamp used for the “author” field.

GIT_COMMITTER_NAME sets the human name for the “committer” field.

GIT_COMMITTER_EMAIL is the email address for the “committer” field.

GIT_COMMITTER_DATE is used for the timestamp in the “committer” field.

EMAIL is the fallback email address in case the user.email configuration value isn’t set. If this isn’t
set, Git falls back to the system user and host names.

<# Networking
Git uses the curl library to do network operations over HTTP, so GIT_CURL_VERBOSE tells Git to emit all
the messages generated by that library. This is similar to doing curl -v on the command line.

GIT_SSL_NO_VERIFY tells Git not to verify SSL certificates. This can sometimes be necessary if you’re
using a self-signed certificate to serve Git repositories over HTTPS, or you’re in the middle of setting
up a Git server but haven’t installed a full certificate yet.

If the data rate of an HTTP operation is lower than GIT_HTTP_LOW_SPEED_LIMIT bytes per second for
longer than GIT_HTTP_LOW_SPEED_TIME seconds, Git will abort that operation. These values override
the http.lowSpeedLimit and http.lowSpeedTime configuration values.

GIT_HTTP_USER_AGENT sets the user-agent string used by Git when communicating over HTTP. The
default is a value like git/2.0.0.

<# Diffing and Merging
GIT_DIFF_OPTS is a bit of a misnomer. The only valid values are -u<n> or --unified=<n>, which
controls the number of context lines shown in a git diff command.

GIT_EXTERNAL_DIFF is used as an override for the diff.external configuration value. If it’s set, Git will
invoke this program when git diff is invoked.

GIT_DIFF_PATH_COUNTER and GIT_DIFF_PATH_TOTAL are useful from inside the program specified by

GIT_EXTERNAL_DIFF or diff.external. The former represents which file in a series is being diffed
(starting with 1), and the latter is the total number of files in the batch.

GIT_MERGE_VERBOSITY controls the output for the recursive merge strategy. The allowed values are as
follows:
• 0 outputs nothing, except possibly a single error message.
• 1 shows only conflicts.
• 2 also shows file changes.
• 3 shows when files are skipped because they haven’t changed.
• 4 shows all paths as they are processed.
• 5 and above show detailed debugging information.
The default value is 2.

<# Debugging
Want to really know what Git is up to? Git has a fairly complete set of traces embedded, and all you
need to do is turn them on. The possible values of these variables are as follows:
• “true”, “1”, or “2” – the trace category is written to stderr.
• An absolute path starting with / – the trace output will be written to that file.
GIT_TRACE controls general traces, which don’t fit into any specific category. This includes the
expansion of aliases, and delegation to other sub-programs.
#>
$ GIT_TRACE=true git lga

<# GIT_TRACE_PACK_ACCESS controls tracing of packfile access. The first field is the packfile being
accessed, the second is the offset within that file:
#>
$ GIT_TRACE_PACK_ACCESS=true git status

<# GIT_TRACE_PACKET enables packet-level tracing for network operations.#>
$ GIT_TRACE_PACKET=true git ls-remote origin

<# GIT_TRACE_PERFORMANCE controls logging of performance data. The output shows how long each
particular git invocation takes.
#>
$ GIT_TRACE_PERFORMANCE=true git gc

<# GIT_TRACE_SETUP shows information about what Git is discovering about the repository and
environment it’s interacting with.
#>
$ GIT_TRACE_SETUP=true git status

<# Miscellaneous
GIT_SSH, if specified, is a program that is invoked instead of ssh when Git tries to connect to an SSH
host. It is invoked like $GIT_SSH [username@]host [-p <port>] <command>. Note that this isn’t the
easiest way to customize how ssh is invoked; it won’t support extra command-line parameters, so
you’d have to write a wrapper script and set GIT_SSH to point to it. It’s probably easier just to use the
~/.ssh/config file for that.

<# GIT_ASKPASS is an override for the core.askpass configuration value. This is the program invoked
whenever Git needs to ask the user for credentials, which can expect a text prompt as a commandline argument, and should return the answer on stdout (see Credential Storage for more on this
subsystem).

<# GIT_NAMESPACE controls access to namespaced refs, and is equivalent to the --namespace flag. This is
mostly useful on the server side, where you may want to store multiple forks of a single repository
in one repository, only keeping the refs separate.

<# GIT_FLUSH can be used to force Git to use non-buffered I/O when writing incrementally to stdout. A
value of 1 causes Git to flush more often, a value of 0 causes all output to be buffered. The default
value (if this variable is not set) is to choose an appropriate buffering scheme depending on the
activity and the output mode.

<# GIT_REFLOG_ACTION lets you specify the descriptive text written to the reflog. Here’s an example:#>
$ GIT_REFLOG_ACTION="my action" git commit --allow-empty -m 'My message'
$ git reflog -1